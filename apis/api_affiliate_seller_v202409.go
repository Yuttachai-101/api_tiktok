/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "github.com/Yuttachai-101/api_tiktok/models/affiliate_seller/v202409"
)


// AffiliateSellerV202409APIService AffiliateSellerV202409API service
type AffiliateSellerV202409APIService service

type ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest) ContentType(contentType string) ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409GetOpenCollaborationSettingsResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409OpenCollaborationSettingsGetExecute(r)
}

/*
AffiliateSeller202409OpenCollaborationSettingsGet GetOpenCollaborationSettings
Get the open collaboration settings, including auto add settings.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409OpenCollaborationSettingsGet(ctx context.Context) ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest {
    return ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409GetOpenCollaborationSettingsResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409OpenCollaborationSettingsGetExecute(r ApiAffiliateSeller202409OpenCollaborationSettingsGetRequest) (*affiliate_seller_v202409.AffiliateSeller202409GetOpenCollaborationSettingsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409GetOpenCollaborationSettingsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409OpenCollaborationSettingsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/open_collaboration_settings"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    productId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest) ContentType(contentType string) ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409RemoveOpenCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409OpenCollaborationsProductsProductIdDeleteExecute(r)
}

/*
AffiliateSeller202409OpenCollaborationsProductsProductIdDelete RemoveOpenCollaboration
Remove open collaboration for product. 
You can only remove open collaboration when `status==NORMAL`. When you call this API, the open collaborations will be terminated at `terminated_effective_time`, not immediately, to protect the interests of the creators. After `terminated_effective_time`, the open collaboration is officially terminated and can not be found in the response in [Search Open Collaboration].

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param productId The product id of the open collaboration to be terminated
@return ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409OpenCollaborationsProductsProductIdDelete(ctx context.Context, productId string) ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest {
    return ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest{
        ApiService: a,
        ctx: ctx,
        productId: productId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409RemoveOpenCollaborationResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409OpenCollaborationsProductsProductIdDeleteExecute(r ApiAffiliateSeller202409OpenCollaborationsProductsProductIdDeleteRequest) (*affiliate_seller_v202409.AffiliateSeller202409RemoveOpenCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodDelete
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409RemoveOpenCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409OpenCollaborationsProductsProductIdDelete")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/open_collaborations/products/{product_id}"
    localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    sortOrder *string
    sortField *string
    shopCipher *string
    affiliateSeller202409SearchOpenCollaborationRequestBody *affiliate_seller_v202409.AffiliateSeller202409SearchOpenCollaborationRequestBody
}

// The value of \&quot;page_size\&quot; must be greater than 0 and less than or equal to 100.
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) PageSize(pageSize int64) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// Pagination offset determines where you begin to search for. It&#39;s empty when you raise your first request.
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) PageToken(pageToken string) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// Default value of \&quot;sort_order\&quot; is DESC. Enum: - ASC：means to sort data in ascending order - DESC：means to sort data in descending order
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) SortOrder(sortOrder string) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    r.sortOrder = &sortOrder
    return r
}
// Some sorting fields are as follows: - product_original_price: sort by products&#39; original price. By default, the open collaborations are sorted in descending order by creation time.
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) SortField(sortField string) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    r.sortField = &sortField
    return r
}
// 
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) AffiliateSeller202409SearchOpenCollaborationRequestBody(affiliateSeller202409SearchOpenCollaborationRequestBody affiliate_seller_v202409.AffiliateSeller202409SearchOpenCollaborationRequestBody) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    r.affiliateSeller202409SearchOpenCollaborationRequestBody = &affiliateSeller202409SearchOpenCollaborationRequestBody
    return r
}
func (r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409SearchOpenCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409OpenCollaborationsSearchPostExecute(r)
}

/*
AffiliateSeller202409OpenCollaborationsSearchPost SearchOpenCollaboration
Retrieve all open collaboration information from merchants, including commission rate, add to showcase and post content creator count.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409OpenCollaborationsSearchPost(ctx context.Context) ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest {
    return ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409SearchOpenCollaborationResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409OpenCollaborationsSearchPostExecute(r ApiAffiliateSeller202409OpenCollaborationsSearchPostRequest) (*affiliate_seller_v202409.AffiliateSeller202409SearchOpenCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409SearchOpenCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409OpenCollaborationsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/open_collaborations/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.sortField != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202409SearchOpenCollaborationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    applicationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202409SellerSearchSampleApplicationsFulfillmentsRequestBody *affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsFulfillmentsRequestBody
}

// 
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest) AffiliateSeller202409SellerSearchSampleApplicationsFulfillmentsRequestBody(affiliateSeller202409SellerSearchSampleApplicationsFulfillmentsRequestBody affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsFulfillmentsRequestBody) ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest {
    r.affiliateSeller202409SellerSearchSampleApplicationsFulfillmentsRequestBody = &affiliateSeller202409SellerSearchSampleApplicationsFulfillmentsRequestBody
    return r
}
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsFulfillmentsResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostExecute(r)
}

/*
AffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPost SellerSearchSampleApplicationsFulfillments
You, the seller, can use this API to get the fulfillment status of the specific sample application and whether the fulfillment resulted in orders. This allows Sellers to track the current progress or analyze the results of their sample distribution program.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param applicationId The application identifier.
@return ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPost(ctx context.Context, applicationId string) ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest {
    return ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
        applicationId: applicationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409SellerSearchSampleApplicationsFulfillmentsResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostExecute(r ApiAffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPostRequest) (*affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsFulfillmentsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsFulfillmentsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409SampleApplicationsApplicationIdFulfillmentsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/sample_applications/{application_id}/fulfillments/search"
    localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202409SellerSearchSampleApplicationsFulfillmentsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    applicationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202409SellerReviewSampleApplicationsRequestBody *affiliate_seller_v202409.AffiliateSeller202409SellerReviewSampleApplicationsRequestBody
}

// 
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest) ContentType(contentType string) ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest) AffiliateSeller202409SellerReviewSampleApplicationsRequestBody(affiliateSeller202409SellerReviewSampleApplicationsRequestBody affiliate_seller_v202409.AffiliateSeller202409SellerReviewSampleApplicationsRequestBody) ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest {
    r.affiliateSeller202409SellerReviewSampleApplicationsRequestBody = &affiliateSeller202409SellerReviewSampleApplicationsRequestBody
    return r
}
func (r ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409SellerReviewSampleApplicationsResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409SampleApplicationsApplicationIdReviewPostExecute(r)
}

/*
AffiliateSeller202409SampleApplicationsApplicationIdReviewPost SellerReviewSampleApplications
This API allows the seller to approve or reject the creator's sample application in an open collaboration. When rejecting an application, the seller must provide a specific reason. This API facilitates the management of sample applications by giving sellers the ability to review and update applications according to their criteria and requirements.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param applicationId 
@return ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409SampleApplicationsApplicationIdReviewPost(ctx context.Context, applicationId string) ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest {
    return ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest{
        ApiService: a,
        ctx: ctx,
        applicationId: applicationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409SellerReviewSampleApplicationsResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409SampleApplicationsApplicationIdReviewPostExecute(r ApiAffiliateSeller202409SampleApplicationsApplicationIdReviewPostRequest) (*affiliate_seller_v202409.AffiliateSeller202409SellerReviewSampleApplicationsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409SellerReviewSampleApplicationsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409SampleApplicationsApplicationIdReviewPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/sample_applications/{application_id}/review"
    localVarPath = strings.Replace(localVarPath, "{"+"application_id"+"}", url.PathEscape(parameterValueToString(r.applicationId, "applicationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202409SellerReviewSampleApplicationsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409SampleApplicationsSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    pageSize *int64
    shopCipher *string
    affiliateSeller202409SellerSearchSampleApplicationsRequestBody *affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsRequestBody
}

// 
func (r ApiAffiliateSeller202409SampleApplicationsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409SampleApplicationsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409SampleApplicationsSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202409SampleApplicationsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// Pagination offset determines where you begin to search for. It&#39;s empty when raise your first request.
func (r ApiAffiliateSeller202409SampleApplicationsSearchPostRequest) PageToken(pageToken string) ApiAffiliateSeller202409SampleApplicationsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// The value of \&quot;page_size\&quot; must be greater than 0 and less than or equal to 50.
func (r ApiAffiliateSeller202409SampleApplicationsSearchPostRequest) PageSize(pageSize int64) ApiAffiliateSeller202409SampleApplicationsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202409SampleApplicationsSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409SampleApplicationsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409SampleApplicationsSearchPostRequest) AffiliateSeller202409SellerSearchSampleApplicationsRequestBody(affiliateSeller202409SellerSearchSampleApplicationsRequestBody affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsRequestBody) ApiAffiliateSeller202409SampleApplicationsSearchPostRequest {
    r.affiliateSeller202409SellerSearchSampleApplicationsRequestBody = &affiliateSeller202409SellerSearchSampleApplicationsRequestBody
    return r
}
func (r ApiAffiliateSeller202409SampleApplicationsSearchPostRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409SampleApplicationsSearchPostExecute(r)
}

/*
AffiliateSeller202409SampleApplicationsSearchPost SellerSearchSampleApplications
This API is provided for sellers to query sample applications based on various criteria such as products, creators, or application statuses. By using this API, sellers can retrieve detailed information about sample application records, including the creator's information and the specifics of each application.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202409SampleApplicationsSearchPostRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409SampleApplicationsSearchPost(ctx context.Context) ApiAffiliateSeller202409SampleApplicationsSearchPostRequest {
    return ApiAffiliateSeller202409SampleApplicationsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409SellerSearchSampleApplicationsResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409SampleApplicationsSearchPostExecute(r ApiAffiliateSeller202409SampleApplicationsSearchPostRequest) (*affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409SellerSearchSampleApplicationsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409SampleApplicationsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/sample_applications/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.pageSize != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202409SellerSearchSampleApplicationsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    xTtsAccessToken *string
    contentType *string
    pageSize *int64
    pageToken *string
    shopCipher *string
    affiliateSeller202409SearchTargetCollaborationsRequestBody *affiliate_seller_v202409.AffiliateSeller202409SearchTargetCollaborationsRequestBody
}

// 
func (r ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// The value of \&quot;page_size\&quot; must be 20, 50 or 100.
func (r ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest) PageSize(pageSize int64) ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// Pagination offset determines where you begin to search for. It&#39;s empty when raise your first request.
func (r ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest) PageToken(pageToken string) ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest) AffiliateSeller202409SearchTargetCollaborationsRequestBody(affiliateSeller202409SearchTargetCollaborationsRequestBody affiliate_seller_v202409.AffiliateSeller202409SearchTargetCollaborationsRequestBody) ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest {
    r.affiliateSeller202409SearchTargetCollaborationsRequestBody = &affiliateSeller202409SearchTargetCollaborationsRequestBody
    return r
}
func (r ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409SearchTargetCollaborationsResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409TargetCollaborationsSearchPostExecute(r)
}

/*
AffiliateSeller202409TargetCollaborationsSearchPost SearchTargetCollaborations
This API is used by Seller to search for all existing target collaborations. Sellers can search based on filters such as Invitation name, Invitation ID, Product name, Product ID and Creator name. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409TargetCollaborationsSearchPost(ctx context.Context) ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest {
    return ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409SearchTargetCollaborationsResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409TargetCollaborationsSearchPostExecute(r ApiAffiliateSeller202409TargetCollaborationsSearchPostRequest) (*affiliate_seller_v202409.AffiliateSeller202409SearchTargetCollaborationsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409SearchTargetCollaborationsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409TargetCollaborationsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/target_collaborations/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageSize != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    }
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202409SearchTargetCollaborationsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    targetCollaborationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest) ContentType(contentType string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409RemoveTargetCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteExecute(r)
}

/*
AffiliateSeller202409TargetCollaborationsTargetCollaborationIdDelete RemoveTargetCollaboration
This API is used by Seller to remove affiliate target collaboration.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param targetCollaborationId The unique id of the specified target collaboration. 
@return ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409TargetCollaborationsTargetCollaborationIdDelete(ctx context.Context, targetCollaborationId string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest {
    return ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest{
        ApiService: a,
        ctx: ctx,
        targetCollaborationId: targetCollaborationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409RemoveTargetCollaborationResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteExecute(r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdDeleteRequest) (*affiliate_seller_v202409.AffiliateSeller202409RemoveTargetCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodDelete
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409RemoveTargetCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409TargetCollaborationsTargetCollaborationIdDelete")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/target_collaborations/{target_collaboration_id}"
    localVarPath = strings.Replace(localVarPath, "{"+"target_collaboration_id"+"}", url.PathEscape(parameterValueToString(r.targetCollaborationId, "targetCollaborationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    targetCollaborationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest) ContentType(contentType string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409QueryTargetCollaborationDetailResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetExecute(r)
}

/*
AffiliateSeller202409TargetCollaborationsTargetCollaborationIdGet QueryTargetCollaborationDetail
This API is used by Sellers to get target collaboration information.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param targetCollaborationId Target collaboration id.  
@return ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409TargetCollaborationsTargetCollaborationIdGet(ctx context.Context, targetCollaborationId string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest {
    return ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest{
        ApiService: a,
        ctx: ctx,
        targetCollaborationId: targetCollaborationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409QueryTargetCollaborationDetailResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetExecute(r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdGetRequest) (*affiliate_seller_v202409.AffiliateSeller202409QueryTargetCollaborationDetailResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409QueryTargetCollaborationDetailResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409TargetCollaborationsTargetCollaborationIdGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/target_collaborations/{target_collaboration_id}"
    localVarPath = strings.Replace(localVarPath, "{"+"target_collaboration_id"+"}", url.PathEscape(parameterValueToString(r.targetCollaborationId, "targetCollaborationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202409APIService
    targetCollaborationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202409UpdateTargetCollaborationRequestBody *affiliate_seller_v202409.AffiliateSeller202409UpdateTargetCollaborationRequestBody
}

// 
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest) ContentType(contentType string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest) AffiliateSeller202409UpdateTargetCollaborationRequestBody(affiliateSeller202409UpdateTargetCollaborationRequestBody affiliate_seller_v202409.AffiliateSeller202409UpdateTargetCollaborationRequestBody) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest {
    r.affiliateSeller202409UpdateTargetCollaborationRequestBody = &affiliateSeller202409UpdateTargetCollaborationRequestBody
    return r
}
func (r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest) Execute() (*affiliate_seller_v202409.AffiliateSeller202409UpdateTargetCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutExecute(r)
}

/*
AffiliateSeller202409TargetCollaborationsTargetCollaborationIdPut UpdateTargetCollaboration
This API is used by Seller to update STANDARD target collaboration.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param targetCollaborationId The unique id of specific target collaboration. 
@return ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest
*/
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409TargetCollaborationsTargetCollaborationIdPut(ctx context.Context, targetCollaborationId string) ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest {
    return ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest{
        ApiService: a,
        ctx: ctx,
        targetCollaborationId: targetCollaborationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202409UpdateTargetCollaborationResponse
func (a *AffiliateSellerV202409APIService) AffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutExecute(r ApiAffiliateSeller202409TargetCollaborationsTargetCollaborationIdPutRequest) (*affiliate_seller_v202409.AffiliateSeller202409UpdateTargetCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPut
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202409.AffiliateSeller202409UpdateTargetCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202409APIService.AffiliateSeller202409TargetCollaborationsTargetCollaborationIdPut")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202409/target_collaborations/{target_collaboration_id}"
    localVarPath = strings.Replace(localVarPath, "{"+"target_collaboration_id"+"}", url.PathEscape(parameterValueToString(r.targetCollaborationId, "targetCollaborationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202409UpdateTargetCollaborationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
