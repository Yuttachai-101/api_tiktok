/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"

    "tiktokshop/open/sdk_golang/models/authorization/v202405"
)


// AuthorizationV202405APIService AuthorizationV202405API service
type AuthorizationV202405APIService service

type ApiAuthorization202405CategoryAssetsGetRequest struct {
    ctx context.Context
    ApiService *AuthorizationV202405APIService
    xTtsAccessToken *string
    contentType *string
}

// 
func (r ApiAuthorization202405CategoryAssetsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAuthorization202405CategoryAssetsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAuthorization202405CategoryAssetsGetRequest) ContentType(contentType string) ApiAuthorization202405CategoryAssetsGetRequest {
    r.contentType = &contentType
    return r
}
func (r ApiAuthorization202405CategoryAssetsGetRequest) Execute() (*authorization_v202405.Authorization202405GetAuthorizedCategoryAssetsResponse, *http.Response, error) {
    return r.ApiService.Authorization202405CategoryAssetsGetExecute(r)
}

/*
Authorization202405CategoryAssetsGet GetAuthorizedCategoryAssets
Retrieves the list of business category assets authorized by a partner for an app.
Partner authorization is required before an app can access the data of a partner, and this access is granted based on business categories. Use this API to check which business category assets are currently authorized for an app and obtain the corresponding category asset cipher for use as an input parameter in affiliate partner related APIs. 
For more information about partner authorization, refer to [Partner authorization guide](678e3a3978f4c20311b8b555).
Target partner: All

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAuthorization202405CategoryAssetsGetRequest
*/
func (a *AuthorizationV202405APIService) Authorization202405CategoryAssetsGet(ctx context.Context) ApiAuthorization202405CategoryAssetsGetRequest {
    return ApiAuthorization202405CategoryAssetsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Authorization202405GetAuthorizedCategoryAssetsResponse
func (a *AuthorizationV202405APIService) Authorization202405CategoryAssetsGetExecute(r ApiAuthorization202405CategoryAssetsGetRequest) (*authorization_v202405.Authorization202405GetAuthorizedCategoryAssetsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *authorization_v202405.Authorization202405GetAuthorizedCategoryAssetsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationV202405APIService.Authorization202405CategoryAssetsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/authorization/202405/category_assets"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
