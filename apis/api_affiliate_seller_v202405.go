/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "tiktokshop/open/sdk_golang/models/affiliate_seller/v202405"
)


// AffiliateSellerV202405APIService AffiliateSellerV202405API service
type AffiliateSellerV202405APIService service

type ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202405APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202405EditOpenCollaborationSettingsRequestBody *affiliate_seller_v202405.AffiliateSeller202405EditOpenCollaborationSettingsRequestBody
}

// 
func (r ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest) ContentType(contentType string) ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest) AffiliateSeller202405EditOpenCollaborationSettingsRequestBody(affiliateSeller202405EditOpenCollaborationSettingsRequestBody affiliate_seller_v202405.AffiliateSeller202405EditOpenCollaborationSettingsRequestBody) ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest {
    r.affiliateSeller202405EditOpenCollaborationSettingsRequestBody = &affiliateSeller202405EditOpenCollaborationSettingsRequestBody
    return r
}
func (r ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest) Execute() (*affiliate_seller_v202405.AffiliateSeller202405EditOpenCollaborationSettingsResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202405OpenCollaborationSettingsPostExecute(r)
}

/*
AffiliateSeller202405OpenCollaborationSettingsPost EditOpenCollaborationSettings
This API is used to edit a Seller's open collaboration settings. It allows you to enroll your existing product catalog and all future products into an open collaboration plan. It also allows you to turn this setting off at any point. By default, this option is turned off for all Sellers. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest
*/
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OpenCollaborationSettingsPost(ctx context.Context) ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest {
    return ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202405EditOpenCollaborationSettingsResponse
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OpenCollaborationSettingsPostExecute(r ApiAffiliateSeller202405OpenCollaborationSettingsPostRequest) (*affiliate_seller_v202405.AffiliateSeller202405EditOpenCollaborationSettingsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202405.AffiliateSeller202405EditOpenCollaborationSettingsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202405APIService.AffiliateSeller202405OpenCollaborationSettingsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202405/open_collaboration_settings"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202405EditOpenCollaborationSettingsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202405APIService
    openCollaborationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody *affiliate_seller_v202405.AffiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody
}

// 
func (r ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest) ContentType(contentType string) ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest) AffiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody(affiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody affiliate_seller_v202405.AffiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody) ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest {
    r.affiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody = &affiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody
    return r
}
func (r ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest) Execute() (*affiliate_seller_v202405.AffiliateSeller202405RemoveCreatorFromOpenCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostExecute(r)
}

/*
AffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPost RemoveCreatorFromOpenCollaboration
This API is used to remove creators from open collaboration. Please note, due to current platform design, creators can still rejoin an open collaboration after removal. Partners/Sellers can call this API again to remove the creator again. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param openCollaborationId Open collaboration ID. This API is only applicable to the seller removing creators from open collaboration.
@return ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest
*/
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPost(ctx context.Context, openCollaborationId string) ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest {
    return ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest{
        ApiService: a,
        ctx: ctx,
        openCollaborationId: openCollaborationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202405RemoveCreatorFromOpenCollaborationResponse
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostExecute(r ApiAffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPostRequest) (*affiliate_seller_v202405.AffiliateSeller202405RemoveCreatorFromOpenCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202405.AffiliateSeller202405RemoveCreatorFromOpenCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202405APIService.AffiliateSeller202405OpenCollaborationsOpenCollaborationIdRemoveCreatorPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202405/open_collaborations/{open_collaboration_id}/remove_creator"
    localVarPath = strings.Replace(localVarPath, "{"+"open_collaboration_id"+"}", url.PathEscape(parameterValueToString(r.openCollaborationId, "openCollaborationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202405OpenCollaborationsPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202405APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202405CreateOpenCollaborationRequestBody *affiliate_seller_v202405.AffiliateSeller202405CreateOpenCollaborationRequestBody
}

// 
func (r ApiAffiliateSeller202405OpenCollaborationsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202405OpenCollaborationsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202405OpenCollaborationsPostRequest) ContentType(contentType string) ApiAffiliateSeller202405OpenCollaborationsPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202405OpenCollaborationsPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202405OpenCollaborationsPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202405OpenCollaborationsPostRequest) AffiliateSeller202405CreateOpenCollaborationRequestBody(affiliateSeller202405CreateOpenCollaborationRequestBody affiliate_seller_v202405.AffiliateSeller202405CreateOpenCollaborationRequestBody) ApiAffiliateSeller202405OpenCollaborationsPostRequest {
    r.affiliateSeller202405CreateOpenCollaborationRequestBody = &affiliateSeller202405CreateOpenCollaborationRequestBody
    return r
}
func (r ApiAffiliateSeller202405OpenCollaborationsPostRequest) Execute() (*affiliate_seller_v202405.AffiliateSeller202405CreateOpenCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202405OpenCollaborationsPostExecute(r)
}

/*
AffiliateSeller202405OpenCollaborationsPost CreateOpenCollaboration
This API allows the seller to create an open collaboration. You create an open collaboration by selecting products and setting a commission rate.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202405OpenCollaborationsPostRequest
*/
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OpenCollaborationsPost(ctx context.Context) ApiAffiliateSeller202405OpenCollaborationsPostRequest {
    return ApiAffiliateSeller202405OpenCollaborationsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202405CreateOpenCollaborationResponse
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OpenCollaborationsPostExecute(r ApiAffiliateSeller202405OpenCollaborationsPostRequest) (*affiliate_seller_v202405.AffiliateSeller202405CreateOpenCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202405.AffiliateSeller202405CreateOpenCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202405APIService.AffiliateSeller202405OpenCollaborationsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202405/open_collaborations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202405CreateOpenCollaborationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202405APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    sortOrder *string
    sortField *string
    pageToken *string
    shopCipher *string
    affiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody *affiliate_seller_v202405.AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody
}

// The number of results to be returned per page. Valid range: [1-20].
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) PageSize(pageSize int64) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// The sort order for the sort_field parameter. Default: ASC Possible values: - ASC: Ascending order - DESC: Descending order
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) SortOrder(sortOrder string) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    r.sortOrder = &sortOrder
    return r
}
// The returned results will be sorted by the specified field. See the description of the field values in the request body for more information about each field. Default: commission_rate Possible values: - commission_rate - product_sales_price - commission - units_sold
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) SortField(sortField string) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    r.sortField = &sortField
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the next_page_token from a previous response. It is not needed for the first page.
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) PageToken(pageToken string) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody(affiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody affiliate_seller_v202405.AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    r.affiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody = &affiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody
    return r
}
func (r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) Execute() (*affiliate_seller_v202405.AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202405OpenCollaborationsProductsSearchPostExecute(r)
}

/*
AffiliateSeller202405OpenCollaborationsProductsSearchPost SellerSearchAffiliateOpenCollaborationProduct
This API is used to search the information of products with open collaboration by category, commission rate, and keywords. It will return all products on the TikTok Shop Affiliate Product Marketplace that are in an open collaboration.
Sellers can only search for open collaboration within the regions they are registered to sell in.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest
*/
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OpenCollaborationsProductsSearchPost(ctx context.Context) ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest {
    return ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductResponse
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OpenCollaborationsProductsSearchPostExecute(r ApiAffiliateSeller202405OpenCollaborationsProductsSearchPostRequest) (*affiliate_seller_v202405.AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202405.AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202405APIService.AffiliateSeller202405OpenCollaborationsProductsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202405/open_collaborations/products/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.sortField != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    }
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202405OrdersSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202405APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    version *int32
    pageToken *string
    shopCipher *string
}

// The size of one page, which must be greater than 0 and less than or equal to 50.
func (r ApiAffiliateSeller202405OrdersSearchPostRequest) PageSize(pageSize int64) ApiAffiliateSeller202405OrdersSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202405OrdersSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202405OrdersSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202405OrdersSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202405OrdersSearchPostRequest {
    r.contentType = &contentType
    return r
}
// The interface version you want to access
func (r ApiAffiliateSeller202405OrdersSearchPostRequest) Version(version int32) ApiAffiliateSeller202405OrdersSearchPostRequest {
    r.version = &version
    return r
}
// Pagination offset determines where you begin to search for. It&#39;s empty when raise your first request.
func (r ApiAffiliateSeller202405OrdersSearchPostRequest) PageToken(pageToken string) ApiAffiliateSeller202405OrdersSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiAffiliateSeller202405OrdersSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202405OrdersSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202405OrdersSearchPostRequest) Execute() (*affiliate_seller_v202405.AffiliateSeller202405SearchSellerAffiliateOrdersResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202405OrdersSearchPostExecute(r)
}

/*
AffiliateSeller202405OrdersSearchPost SearchSellerAffiliateOrders
This API allows the partner to retrieve a list of affiliate orders (orders which are affiliate-commission eligible) generated by a seller, returning the order ID and the product ID. Using this, the partner can track their affiliate-conversions on behalf of a seller, using the order ID.
For now, this API returns all historical Affiliate Orders. We do not provide any filtering mechanisms (based on timestamp) at this time. We will provide this functionality in a future iteration. Thus this API is technically a "Get Affiliate Orders List" at this stage, but it will be improved in the future to be a search based API (with robust filtering).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202405OrdersSearchPostRequest
*/
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OrdersSearchPost(ctx context.Context) ApiAffiliateSeller202405OrdersSearchPostRequest {
    return ApiAffiliateSeller202405OrdersSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202405SearchSellerAffiliateOrdersResponse
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405OrdersSearchPostExecute(r ApiAffiliateSeller202405OrdersSearchPostRequest) (*affiliate_seller_v202405.AffiliateSeller202405SearchSellerAffiliateOrdersResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202405.AffiliateSeller202405SearchSellerAffiliateOrdersResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202405APIService.AffiliateSeller202405OrdersSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202405/orders/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.version != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
    }
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202405APIService
    productId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest) ContentType(contentType string) ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest) Execute() (*affiliate_seller_v202405.AffiliateSeller202405GenerateAffiliateProductPromotionLinkResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostExecute(r)
}

/*
AffiliateSeller202405ProductsProductIdPromotionLinkGeneratePost GenerateAffiliateProductPromotionLink
The user of this API is a partner developer, on behalf of Sellers.
This API is used to generate affiliate exclusive product link based on all open collaboration products available within the TikTok Shop Affiliate Product Marketplace.
This API generates a link, at the product ID level (which belongs to a Seller). This link, can be distributed to creators, by the partner developer(the user of this API). The creator adds this product to the creators' showcase through this url.
This link, represents an affiliate partner's ability to bring higher matchmaking effectiveness on behalf of a seller. If a creator does indeed add the product to showcase through this link, then the downstream consumer purchases will be able to be attributed to this partner due to the link generation capabilities.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param productId The product identifier.
@return ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest
*/
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405ProductsProductIdPromotionLinkGeneratePost(ctx context.Context, productId string) ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest {
    return ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest{
        ApiService: a,
        ctx: ctx,
        productId: productId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202405GenerateAffiliateProductPromotionLinkResponse
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostExecute(r ApiAffiliateSeller202405ProductsProductIdPromotionLinkGeneratePostRequest) (*affiliate_seller_v202405.AffiliateSeller202405GenerateAffiliateProductPromotionLinkResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202405.AffiliateSeller202405GenerateAffiliateProductPromotionLinkResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202405APIService.AffiliateSeller202405ProductsProductIdPromotionLinkGeneratePost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202405/products/{product_id}/promotion_link/generate"
    localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202405TargetCollaborationsPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202405APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202405CreateTargetCollaborationRequestBody *affiliate_seller_v202405.AffiliateSeller202405CreateTargetCollaborationRequestBody
}

// 
func (r ApiAffiliateSeller202405TargetCollaborationsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202405TargetCollaborationsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202405TargetCollaborationsPostRequest) ContentType(contentType string) ApiAffiliateSeller202405TargetCollaborationsPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202405TargetCollaborationsPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202405TargetCollaborationsPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202405TargetCollaborationsPostRequest) AffiliateSeller202405CreateTargetCollaborationRequestBody(affiliateSeller202405CreateTargetCollaborationRequestBody affiliate_seller_v202405.AffiliateSeller202405CreateTargetCollaborationRequestBody) ApiAffiliateSeller202405TargetCollaborationsPostRequest {
    r.affiliateSeller202405CreateTargetCollaborationRequestBody = &affiliateSeller202405CreateTargetCollaborationRequestBody
    return r
}
func (r ApiAffiliateSeller202405TargetCollaborationsPostRequest) Execute() (*affiliate_seller_v202405.AffiliateSeller202405CreateTargetCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202405TargetCollaborationsPostExecute(r)
}

/*
AffiliateSeller202405TargetCollaborationsPost CreateTargetCollaboration
This API is used to create a target collaboration.
A target collaboration is a collaboration between a seller selected set of products (including a commission payout) and a set of creators the seller has added (invited) to the collaboration. Target collaborations are private and not visible in the Creator Marketplace to all creators; they are only visible to those that have been added to the collaboration.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202405TargetCollaborationsPostRequest
*/
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405TargetCollaborationsPost(ctx context.Context) ApiAffiliateSeller202405TargetCollaborationsPostRequest {
    return ApiAffiliateSeller202405TargetCollaborationsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202405CreateTargetCollaborationResponse
func (a *AffiliateSellerV202405APIService) AffiliateSeller202405TargetCollaborationsPostExecute(r ApiAffiliateSeller202405TargetCollaborationsPostRequest) (*affiliate_seller_v202405.AffiliateSeller202405CreateTargetCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202405.AffiliateSeller202405CreateTargetCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202405APIService.AffiliateSeller202405TargetCollaborationsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202405/target_collaborations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202405CreateTargetCollaborationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
