/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "github.com/Yuttachai-101/api_tiktok/models/affiliate_seller/v202505"
)


// AffiliateSellerV202505APIService AffiliateSellerV202505API service
type AffiliateSellerV202505APIService service

type ApiAffiliateSeller202505ConversationsGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202505APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    onlyNeedConversationId *bool
    shopCipher *string
    affiliateSeller202505GetConversationListRequestBody *affiliate_seller_v202505.AffiliateSeller202505GetConversationListRequestBody
}

// The maximum number of queries. The maximum number is 50.
func (r ApiAffiliateSeller202505ConversationsGetRequest) PageSize(pageSize int64) ApiAffiliateSeller202505ConversationsGetRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202505ConversationsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202505ConversationsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202505ConversationsGetRequest) ContentType(contentType string) ApiAffiliateSeller202505ConversationsGetRequest {
    r.contentType = &contentType
    return r
}
// Pagination offset determines where you begin to query. It&#39;s empty when you raise your first request.
func (r ApiAffiliateSeller202505ConversationsGetRequest) PageToken(pageToken string) ApiAffiliateSeller202505ConversationsGetRequest {
    r.pageToken = &pageToken
    return r
}
// - If &#x60;true&#x60;, only &#x60;conversation_id&#x60; in &#x60;conversation&#x60; is returned.  - If &#x60;false&#x60;, all fields in conversation&#x60; are returned. &#x60;true&#x60; by default.
func (r ApiAffiliateSeller202505ConversationsGetRequest) OnlyNeedConversationId(onlyNeedConversationId bool) ApiAffiliateSeller202505ConversationsGetRequest {
    r.onlyNeedConversationId = &onlyNeedConversationId
    return r
}
// 
func (r ApiAffiliateSeller202505ConversationsGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202505ConversationsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202505ConversationsGetRequest) AffiliateSeller202505GetConversationListRequestBody(affiliateSeller202505GetConversationListRequestBody affiliate_seller_v202505.AffiliateSeller202505GetConversationListRequestBody) ApiAffiliateSeller202505ConversationsGetRequest {
    r.affiliateSeller202505GetConversationListRequestBody = &affiliateSeller202505GetConversationListRequestBody
    return r
}
func (r ApiAffiliateSeller202505ConversationsGetRequest) Execute() (*affiliate_seller_v202505.AffiliateSeller202505GetConversationListResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202505ConversationsGetExecute(r)
}

/*
AffiliateSeller202505ConversationsGet GetConversationList
Get User's Conversation list.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202505ConversationsGetRequest
*/
func (a *AffiliateSellerV202505APIService) AffiliateSeller202505ConversationsGet(ctx context.Context) ApiAffiliateSeller202505ConversationsGetRequest {
    return ApiAffiliateSeller202505ConversationsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202505GetConversationListResponse
func (a *AffiliateSellerV202505APIService) AffiliateSeller202505ConversationsGetExecute(r ApiAffiliateSeller202505ConversationsGetRequest) (*affiliate_seller_v202505.AffiliateSeller202505GetConversationListResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202505.AffiliateSeller202505GetConversationListResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202505APIService.AffiliateSeller202505ConversationsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202505/conversations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.onlyNeedConversationId != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "only_need_conversation_id", r.onlyNeedConversationId, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202505GetConversationListRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202505APIService
    creatorUserId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest) ContentType(contentType string) ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest) Execute() (*affiliate_seller_v202505.AffiliateSeller202505GetMarketplaceCreatorPerformanceResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetExecute(r)
}

/*
AffiliateSeller202505MarketplaceCreatorsCreatorUserIdGet GetMarketplaceCreatorPerformance
Get the Creator Affiliate's Marketplace information and performance metrics in the last 30 days. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param creatorUserId Creators' TikTok User ID
@return ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest
*/
func (a *AffiliateSellerV202505APIService) AffiliateSeller202505MarketplaceCreatorsCreatorUserIdGet(ctx context.Context, creatorUserId string) ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest {
    return ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest{
        ApiService: a,
        ctx: ctx,
        creatorUserId: creatorUserId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202505GetMarketplaceCreatorPerformanceResponse
func (a *AffiliateSellerV202505APIService) AffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetExecute(r ApiAffiliateSeller202505MarketplaceCreatorsCreatorUserIdGetRequest) (*affiliate_seller_v202505.AffiliateSeller202505GetMarketplaceCreatorPerformanceResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202505.AffiliateSeller202505GetMarketplaceCreatorPerformanceResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202505APIService.AffiliateSeller202505MarketplaceCreatorsCreatorUserIdGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202505/marketplace_creators/{creator_user_id}"
    localVarPath = strings.Replace(localVarPath, "{"+"creator_user_id"+"}", url.PathEscape(parameterValueToString(r.creatorUserId, "creatorUserId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202505APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    shopCipher *string
    affiliateSeller202505SellerSearchCreatoronMarketplaceRequestBody *affiliate_seller_v202505.AffiliateSeller202505SellerSearchCreatoronMarketplaceRequestBody
}

// The value of \&quot;page_size\&quot; must be 12 or 20
func (r ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest) PageSize(pageSize int64) ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// Pagination offset determines where you begin to search for. It&#39;s empty when raise your first request
func (r ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest) PageToken(pageToken string) ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest) AffiliateSeller202505SellerSearchCreatoronMarketplaceRequestBody(affiliateSeller202505SellerSearchCreatoronMarketplaceRequestBody affiliate_seller_v202505.AffiliateSeller202505SellerSearchCreatoronMarketplaceRequestBody) ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest {
    r.affiliateSeller202505SellerSearchCreatoronMarketplaceRequestBody = &affiliateSeller202505SellerSearchCreatoronMarketplaceRequestBody
    return r
}
func (r ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest) Execute() (*affiliate_seller_v202505.AffiliateSeller202505SellerSearchCreatoronMarketplaceResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202505MarketplaceCreatorsSearchPostExecute(r)
}

/*
AffiliateSeller202505MarketplaceCreatorsSearchPost SellerSearchCreatoronMarketplace
This API is used by Sellers to search for Creators in the Creator Marketplace. Sellers can search based on filters such as GMV, keywords, and Creator follower demographics. All the data returned is for the last 30 days.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest
*/
func (a *AffiliateSellerV202505APIService) AffiliateSeller202505MarketplaceCreatorsSearchPost(ctx context.Context) ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest {
    return ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202505SellerSearchCreatoronMarketplaceResponse
func (a *AffiliateSellerV202505APIService) AffiliateSeller202505MarketplaceCreatorsSearchPostExecute(r ApiAffiliateSeller202505MarketplaceCreatorsSearchPostRequest) (*affiliate_seller_v202505.AffiliateSeller202505SellerSearchCreatoronMarketplaceResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202505.AffiliateSeller202505SellerSearchCreatoronMarketplaceResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202505APIService.AffiliateSeller202505MarketplaceCreatorsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202505/marketplace_creators/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202505SellerSearchCreatoronMarketplaceRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
