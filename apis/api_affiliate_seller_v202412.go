/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "github.com/Yuttachai-101/api_tiktok/models/affiliate_seller/v202412"
)


// AffiliateSellerV202412APIService AffiliateSellerV202412API service
type AffiliateSellerV202412APIService service

type ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    conversationId string
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    shopCipher *string
}

// The maximum number of queries. The maximum number is 20.
func (r ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest) PageSize(pageSize int64) ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest) ContentType(contentType string) ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest {
    r.contentType = &contentType
    return r
}
// Pagination offset determines where you begin to query. It&#39;s empty when you raise your first request.
func (r ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest) PageToken(pageToken string) ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412GetMessageintheConversationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412ConversationConversationIdMessagesGetExecute(r)
}

/*
AffiliateSeller202412ConversationConversationIdMessagesGet GetMessageintheConversation
Get chat history in one conversation.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param conversationId The conversation identifier.
@return ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationConversationIdMessagesGet(ctx context.Context, conversationId string) ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest {
    return ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest{
        ApiService: a,
        ctx: ctx,
        conversationId: conversationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412GetMessageintheConversationResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationConversationIdMessagesGetExecute(r ApiAffiliateSeller202412ConversationConversationIdMessagesGetRequest) (*affiliate_seller_v202412.AffiliateSeller202412GetMessageintheConversationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412GetMessageintheConversationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412ConversationConversationIdMessagesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/conversation/{conversation_id}/messages"
    localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    conversationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202412SendIMMessageRequestBody *affiliate_seller_v202412.AffiliateSeller202412SendIMMessageRequestBody
}

// 
func (r ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest) ContentType(contentType string) ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest) AffiliateSeller202412SendIMMessageRequestBody(affiliateSeller202412SendIMMessageRequestBody affiliate_seller_v202412.AffiliateSeller202412SendIMMessageRequestBody) ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest {
    r.affiliateSeller202412SendIMMessageRequestBody = &affiliateSeller202412SendIMMessageRequestBody
    return r
}
func (r ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412SendIMMessageResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412ConversationsConversationIdMessagesPostExecute(r)
}

/*
AffiliateSeller202412ConversationsConversationIdMessagesPost SendIMMessage
The API for sending IM messages.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param conversationId Conversion unique id
@return ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationsConversationIdMessagesPost(ctx context.Context, conversationId string) ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest {
    return ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest{
        ApiService: a,
        ctx: ctx,
        conversationId: conversationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412SendIMMessageResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationsConversationIdMessagesPostExecute(r ApiAffiliateSeller202412ConversationsConversationIdMessagesPostRequest) (*affiliate_seller_v202412.AffiliateSeller202412SendIMMessageResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412SendIMMessageResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412ConversationsConversationIdMessagesPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/conversations/{conversation_id}/messages"
    localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202412SendIMMessageRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412ConversationsGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    onlyNeedConversationId *bool
    conversationStatus *string
    shopCipher *string
    affiliateSeller202412GetConversationListRequestBody *affiliate_seller_v202412.AffiliateSeller202412GetConversationListRequestBody
}

// The maximum number of queries. The maximum number is 50.
func (r ApiAffiliateSeller202412ConversationsGetRequest) PageSize(pageSize int64) ApiAffiliateSeller202412ConversationsGetRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202412ConversationsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412ConversationsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412ConversationsGetRequest) ContentType(contentType string) ApiAffiliateSeller202412ConversationsGetRequest {
    r.contentType = &contentType
    return r
}
// Pagination offset determines where you begin to query. It&#39;s empty when you raise your first request.
func (r ApiAffiliateSeller202412ConversationsGetRequest) PageToken(pageToken string) ApiAffiliateSeller202412ConversationsGetRequest {
    r.pageToken = &pageToken
    return r
}
// - If &#x60;true&#x60;, only &#x60;conversation_id&#x60; in &#x60;conversation&#x60; is returned.  - If &#x60;false&#x60;, all fields in conversation&#x60; are returned. &#x60;true&#x60; by default.
func (r ApiAffiliateSeller202412ConversationsGetRequest) OnlyNeedConversationId(onlyNeedConversationId bool) ApiAffiliateSeller202412ConversationsGetRequest {
    r.onlyNeedConversationId = &onlyNeedConversationId
    return r
}
// Filter the list of IM conversations returned based on the status. Possible values:  - ALL: Retrieve all conversations regardless of the status. - UNREAD: Retrieve all conversations with messages that the seller has not read yet. The messages stay unread until explicitly marked as read by calling [Mark Conversation Read](6791db761882810314a991a8). Replying to a message does not change the read / unread status. - UNREPLIED: Retrieve all conversations in which the seller is not the last message sender. This filter helps you to efficiently manage and prioritize conversations.
func (r ApiAffiliateSeller202412ConversationsGetRequest) ConversationStatus(conversationStatus string) ApiAffiliateSeller202412ConversationsGetRequest {
    r.conversationStatus = &conversationStatus
    return r
}
// 
func (r ApiAffiliateSeller202412ConversationsGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412ConversationsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412ConversationsGetRequest) AffiliateSeller202412GetConversationListRequestBody(affiliateSeller202412GetConversationListRequestBody affiliate_seller_v202412.AffiliateSeller202412GetConversationListRequestBody) ApiAffiliateSeller202412ConversationsGetRequest {
    r.affiliateSeller202412GetConversationListRequestBody = &affiliateSeller202412GetConversationListRequestBody
    return r
}
func (r ApiAffiliateSeller202412ConversationsGetRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412GetConversationListResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412ConversationsGetExecute(r)
}

/*
AffiliateSeller202412ConversationsGet GetConversationList
Get User's Conversation list.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202412ConversationsGetRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationsGet(ctx context.Context) ApiAffiliateSeller202412ConversationsGetRequest {
    return ApiAffiliateSeller202412ConversationsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412GetConversationListResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationsGetExecute(r ApiAffiliateSeller202412ConversationsGetRequest) (*affiliate_seller_v202412.AffiliateSeller202412GetConversationListResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412GetConversationListResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412ConversationsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/conversations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.onlyNeedConversationId != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "only_need_conversation_id", r.onlyNeedConversationId, "")
    }
    if r.conversationStatus != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "conversation_status", r.conversationStatus, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202412GetConversationListRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest) ContentType(contentType string) ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412GetLatestUnreadMessagesResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412ConversationsMessagesListNewestGetExecute(r)
}

/*
AffiliateSeller202412ConversationsMessagesListNewestGet GetLatestUnreadMessages
Get the unread messages from the last minute.
You are recommended to use the Webhook, New Message Listener, for the message notification.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationsMessagesListNewestGet(ctx context.Context) ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest {
    return ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412GetLatestUnreadMessagesResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationsMessagesListNewestGetExecute(r ApiAffiliateSeller202412ConversationsMessagesListNewestGetRequest) (*affiliate_seller_v202412.AffiliateSeller202412GetLatestUnreadMessagesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412GetLatestUnreadMessagesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412ConversationsMessagesListNewestGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/conversations/messages/list/newest"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412ConversationsPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202412CreateConversationwithcreatorRequestBody *affiliate_seller_v202412.AffiliateSeller202412CreateConversationwithcreatorRequestBody
}

// 
func (r ApiAffiliateSeller202412ConversationsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412ConversationsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412ConversationsPostRequest) ContentType(contentType string) ApiAffiliateSeller202412ConversationsPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202412ConversationsPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412ConversationsPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412ConversationsPostRequest) AffiliateSeller202412CreateConversationwithcreatorRequestBody(affiliateSeller202412CreateConversationwithcreatorRequestBody affiliate_seller_v202412.AffiliateSeller202412CreateConversationwithcreatorRequestBody) ApiAffiliateSeller202412ConversationsPostRequest {
    r.affiliateSeller202412CreateConversationwithcreatorRequestBody = &affiliateSeller202412CreateConversationwithcreatorRequestBody
    return r
}
func (r ApiAffiliateSeller202412ConversationsPostRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412CreateConversationwithcreatorResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412ConversationsPostExecute(r)
}

/*
AffiliateSeller202412ConversationsPost CreateConversationwithcreator
Get the existing conversation or create a new conversation with the specified TikTok creator for later communication.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202412ConversationsPostRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationsPost(ctx context.Context) ApiAffiliateSeller202412ConversationsPostRequest {
    return ApiAffiliateSeller202412ConversationsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412CreateConversationwithcreatorResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversationsPostExecute(r ApiAffiliateSeller202412ConversationsPostRequest) (*affiliate_seller_v202412.AffiliateSeller202412CreateConversationwithcreatorResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412CreateConversationwithcreatorResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412ConversationsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/conversations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202412CreateConversationwithcreatorRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412ConversatonsReadPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202412MarkConversationReadRequestBody *affiliate_seller_v202412.AffiliateSeller202412MarkConversationReadRequestBody
}

// 
func (r ApiAffiliateSeller202412ConversatonsReadPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412ConversatonsReadPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412ConversatonsReadPostRequest) ContentType(contentType string) ApiAffiliateSeller202412ConversatonsReadPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202412ConversatonsReadPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412ConversatonsReadPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412ConversatonsReadPostRequest) AffiliateSeller202412MarkConversationReadRequestBody(affiliateSeller202412MarkConversationReadRequestBody affiliate_seller_v202412.AffiliateSeller202412MarkConversationReadRequestBody) ApiAffiliateSeller202412ConversatonsReadPostRequest {
    r.affiliateSeller202412MarkConversationReadRequestBody = &affiliateSeller202412MarkConversationReadRequestBody
    return r
}
func (r ApiAffiliateSeller202412ConversatonsReadPostRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412MarkConversationReadResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412ConversatonsReadPostExecute(r)
}

/*
AffiliateSeller202412ConversatonsReadPost MarkConversationRead
Mark the messages in the specified conversations to be read.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202412ConversatonsReadPostRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversatonsReadPost(ctx context.Context) ApiAffiliateSeller202412ConversatonsReadPostRequest {
    return ApiAffiliateSeller202412ConversatonsReadPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412MarkConversationReadResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412ConversatonsReadPostExecute(r ApiAffiliateSeller202412ConversatonsReadPostRequest) (*affiliate_seller_v202412.AffiliateSeller202412MarkConversationReadResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412MarkConversationReadResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412ConversatonsReadPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/conversatons/read"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202412MarkConversationReadRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    pageSize *int64
    productId *string
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    shopCipher *string
}

// The value of \&quot;page_size\&quot; must be greater than 0 and less than or equal to 100.
func (r ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest) PageSize(pageSize int64) ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest {
    r.pageSize = &pageSize
    return r
}
// The product ID that needs to be queried.
func (r ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest) ProductId(productId string) ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest {
    r.productId = &productId
    return r
}
// 
func (r ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest) ContentType(contentType string) ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest {
    r.contentType = &contentType
    return r
}
// Pagination offset determines where you begin to search for. It&#39;s empty when you raise your first request.
func (r ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest) PageToken(pageToken string) ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412GetOpenCollaborationCreatorContentDetailResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetExecute(r)
}

/*
AffiliateSeller202412OpenCollaborationsCreatorContentDetailsGet GetOpenCollaborationCreatorContentDetail
This API allows the seller to get the creator content details of specified open collaboration.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412OpenCollaborationsCreatorContentDetailsGet(ctx context.Context) ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest {
    return ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412GetOpenCollaborationCreatorContentDetailResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetExecute(r ApiAffiliateSeller202412OpenCollaborationsCreatorContentDetailsGetRequest) (*affiliate_seller_v202412.AffiliateSeller202412GetOpenCollaborationCreatorContentDetailResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412GetOpenCollaborationCreatorContentDetailResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412OpenCollaborationsCreatorContentDetailsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/open_collaborations/creator_content_details"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.productId == nil {
        return localVarReturnValue, nil, reportError("productId is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412OpenCollaborationsPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202412CreateOpenCollaborationRequestBody *affiliate_seller_v202412.AffiliateSeller202412CreateOpenCollaborationRequestBody
}

// 
func (r ApiAffiliateSeller202412OpenCollaborationsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412OpenCollaborationsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412OpenCollaborationsPostRequest) ContentType(contentType string) ApiAffiliateSeller202412OpenCollaborationsPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202412OpenCollaborationsPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412OpenCollaborationsPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412OpenCollaborationsPostRequest) AffiliateSeller202412CreateOpenCollaborationRequestBody(affiliateSeller202412CreateOpenCollaborationRequestBody affiliate_seller_v202412.AffiliateSeller202412CreateOpenCollaborationRequestBody) ApiAffiliateSeller202412OpenCollaborationsPostRequest {
    r.affiliateSeller202412CreateOpenCollaborationRequestBody = &affiliateSeller202412CreateOpenCollaborationRequestBody
    return r
}
func (r ApiAffiliateSeller202412OpenCollaborationsPostRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412CreateOpenCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412OpenCollaborationsPostExecute(r)
}

/*
AffiliateSeller202412OpenCollaborationsPost CreateOpenCollaboration
This API allows the seller to create an open collaboration. You create an open collaboration by selecting products and setting a commission rate.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202412OpenCollaborationsPostRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412OpenCollaborationsPost(ctx context.Context) ApiAffiliateSeller202412OpenCollaborationsPostRequest {
    return ApiAffiliateSeller202412OpenCollaborationsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412CreateOpenCollaborationResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412OpenCollaborationsPostExecute(r ApiAffiliateSeller202412OpenCollaborationsPostRequest) (*affiliate_seller_v202412.AffiliateSeller202412CreateOpenCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412CreateOpenCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412OpenCollaborationsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/open_collaborations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202412CreateOpenCollaborationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    sortOrder *string
    sortField *string
    shopCipher *string
    affiliateSeller202412SearchOpenCollaborationRequestBody *affiliate_seller_v202412.AffiliateSeller202412SearchOpenCollaborationRequestBody
}

// The value of \&quot;page_size\&quot; must be greater than 0 and less than or equal to 100.
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) PageSize(pageSize int64) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    r.contentType = &contentType
    return r
}
// Pagination offset determines where you begin to search for. It&#39;s empty when you raise your first request.
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) PageToken(pageToken string) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// Default value of \&quot;sort_order\&quot; is DESC. Enum: - ASC：means to sort data in ascending order - DESC：means to sort data in descending order
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) SortOrder(sortOrder string) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    r.sortOrder = &sortOrder
    return r
}
// Some sorting fields are as follows: - product_original_price: sort by products&#39; original price. By default, the open collaborations are sorted in descending order by creation time.
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) SortField(sortField string) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    r.sortField = &sortField
    return r
}
// 
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) AffiliateSeller202412SearchOpenCollaborationRequestBody(affiliateSeller202412SearchOpenCollaborationRequestBody affiliate_seller_v202412.AffiliateSeller202412SearchOpenCollaborationRequestBody) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    r.affiliateSeller202412SearchOpenCollaborationRequestBody = &affiliateSeller202412SearchOpenCollaborationRequestBody
    return r
}
func (r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412SearchOpenCollaborationResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412OpenCollaborationsSearchPostExecute(r)
}

/*
AffiliateSeller202412OpenCollaborationsSearchPost SearchOpenCollaboration
Retrieve all open collaboration information from merchants, including commission rate, add to showcase and post content creator count.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412OpenCollaborationsSearchPost(ctx context.Context) ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest {
    return ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412SearchOpenCollaborationResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412OpenCollaborationsSearchPostExecute(r ApiAffiliateSeller202412OpenCollaborationsSearchPostRequest) (*affiliate_seller_v202412.AffiliateSeller202412SearchOpenCollaborationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412SearchOpenCollaborationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412OpenCollaborationsSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/open_collaborations/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.sortField != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202412SearchOpenCollaborationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202412APIService
    targetCollaborationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest) ContentType(contentType string) ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest) Execute() (*affiliate_seller_v202412.AffiliateSeller202412QueryTargetCollaborationDetailResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetExecute(r)
}

/*
AffiliateSeller202412TargetCollaborationsTargetCollaborationIdGet QueryTargetCollaborationDetail
This API is used by Sellers to get target collaboration information.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param targetCollaborationId Target collaboration id.  
@return ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest
*/
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412TargetCollaborationsTargetCollaborationIdGet(ctx context.Context, targetCollaborationId string) ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest {
    return ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest{
        ApiService: a,
        ctx: ctx,
        targetCollaborationId: targetCollaborationId,
    }
}

// Execute executes the request
//  @return AffiliateSeller202412QueryTargetCollaborationDetailResponse
func (a *AffiliateSellerV202412APIService) AffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetExecute(r ApiAffiliateSeller202412TargetCollaborationsTargetCollaborationIdGetRequest) (*affiliate_seller_v202412.AffiliateSeller202412QueryTargetCollaborationDetailResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202412.AffiliateSeller202412QueryTargetCollaborationDetailResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202412APIService.AffiliateSeller202412TargetCollaborationsTargetCollaborationIdGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202412/target_collaborations/{target_collaboration_id}"
    localVarPath = strings.Replace(localVarPath, "{"+"target_collaboration_id"+"}", url.PathEscape(parameterValueToString(r.targetCollaborationId, "targetCollaborationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
