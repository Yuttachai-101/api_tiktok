/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"

    "tiktokshop/open/sdk_golang/models/affiliate/v202403"
)


// AffiliateV202403APIService AffiliateV202403API service
type AffiliateV202403APIService service

type ApiAffiliate202403AnchorsContentCheckPostRequest struct {
    ctx context.Context
    ApiService *AffiliateV202403APIService
    xTtsAccessToken *string
    contentType *string
    affiliate202403CheckAnchorContentRequestBody *affiliate_v202403.Affiliate202403CheckAnchorContentRequestBody
}

// 
func (r ApiAffiliate202403AnchorsContentCheckPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliate202403AnchorsContentCheckPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliate202403AnchorsContentCheckPostRequest) ContentType(contentType string) ApiAffiliate202403AnchorsContentCheckPostRequest {
    r.contentType = &contentType
    return r
}
func (r ApiAffiliate202403AnchorsContentCheckPostRequest) Affiliate202403CheckAnchorContentRequestBody(affiliate202403CheckAnchorContentRequestBody affiliate_v202403.Affiliate202403CheckAnchorContentRequestBody) ApiAffiliate202403AnchorsContentCheckPostRequest {
    r.affiliate202403CheckAnchorContentRequestBody = &affiliate202403CheckAnchorContentRequestBody
    return r
}
func (r ApiAffiliate202403AnchorsContentCheckPostRequest) Execute() (*affiliate_v202403.Affiliate202403CheckAnchorContentResponse, *http.Response, error) {
    return r.ApiService.Affiliate202403AnchorsContentCheckPostExecute(r)
}

/*
Affiliate202403AnchorsContentCheckPost CheckAnchorContent
This interface is used for checking anchor contents. The interface currently supports verification of anchor title. It will return error if the title has dirty words, punctuation, emoji or less than 30 characters long.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliate202403AnchorsContentCheckPostRequest
*/
func (a *AffiliateV202403APIService) Affiliate202403AnchorsContentCheckPost(ctx context.Context) ApiAffiliate202403AnchorsContentCheckPostRequest {
    return ApiAffiliate202403AnchorsContentCheckPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Affiliate202403CheckAnchorContentResponse
func (a *AffiliateV202403APIService) Affiliate202403AnchorsContentCheckPostExecute(r ApiAffiliate202403AnchorsContentCheckPostRequest) (*affiliate_v202403.Affiliate202403CheckAnchorContentResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_v202403.Affiliate202403CheckAnchorContentResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateV202403APIService.Affiliate202403AnchorsContentCheckPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate/202403/anchors/content_check"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliate202403CheckAnchorContentRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
