/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"

    "tiktokshop/open/sdk_golang/models/affiliate/v202309"
)


// AffiliateV202309APIService AffiliateV202309API service
type AffiliateV202309APIService service

type ApiAffiliate202309LiveRoomsGetRequest struct {
    ctx context.Context
    ApiService *AffiliateV202309APIService
    xTtsAccessToken *string
    contentType *string
}

// 
func (r ApiAffiliate202309LiveRoomsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliate202309LiveRoomsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliate202309LiveRoomsGetRequest) ContentType(contentType string) ApiAffiliate202309LiveRoomsGetRequest {
    r.contentType = &contentType
    return r
}
func (r ApiAffiliate202309LiveRoomsGetRequest) Execute() (*affiliate_v202309.Affiliate202309GetLiveRoomInfoResponse, *http.Response, error) {
    return r.ApiService.Affiliate202309LiveRoomsGetExecute(r)
}

/*
Affiliate202309LiveRoomsGet GetLiveRoomInfo
Developer can utilize this API to get the creator`s last live room information

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliate202309LiveRoomsGetRequest
*/
func (a *AffiliateV202309APIService) Affiliate202309LiveRoomsGet(ctx context.Context) ApiAffiliate202309LiveRoomsGetRequest {
    return ApiAffiliate202309LiveRoomsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Affiliate202309GetLiveRoomInfoResponse
func (a *AffiliateV202309APIService) Affiliate202309LiveRoomsGetExecute(r ApiAffiliate202309LiveRoomsGetRequest) (*affiliate_v202309.Affiliate202309GetLiveRoomInfoResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_v202309.Affiliate202309GetLiveRoomInfoResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateV202309APIService.Affiliate202309LiveRoomsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate/202309/live_rooms"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliate202309ProfilesGetRequest struct {
    ctx context.Context
    ApiService *AffiliateV202309APIService
    xTtsAccessToken *string
    contentType *string
}

// 
func (r ApiAffiliate202309ProfilesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliate202309ProfilesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliate202309ProfilesGetRequest) ContentType(contentType string) ApiAffiliate202309ProfilesGetRequest {
    r.contentType = &contentType
    return r
}
func (r ApiAffiliate202309ProfilesGetRequest) Execute() (*affiliate_v202309.Affiliate202309GetCreatorProfileoldResponse, *http.Response, error) {
    return r.ApiService.Affiliate202309ProfilesGetExecute(r)
}

/*
Affiliate202309ProfilesGet GetCreatorProfileold
This API gets the creator profile information.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliate202309ProfilesGetRequest
*/
func (a *AffiliateV202309APIService) Affiliate202309ProfilesGet(ctx context.Context) ApiAffiliate202309ProfilesGetRequest {
    return ApiAffiliate202309ProfilesGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Affiliate202309GetCreatorProfileoldResponse
func (a *AffiliateV202309APIService) Affiliate202309ProfilesGetExecute(r ApiAffiliate202309ProfilesGetRequest) (*affiliate_v202309.Affiliate202309GetCreatorProfileoldResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_v202309.Affiliate202309GetCreatorProfileoldResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateV202309APIService.Affiliate202309ProfilesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate/202309/profiles"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliate202309ShopProductsGetRequest struct {
    ctx context.Context
    ApiService *AffiliateV202309APIService
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    titleKeyword *string
    sortField *string
    sortOrder *string
}

// Pagination count determines how many products you&#39;ll get after sending the request. 20 is a recommended number.
func (r ApiAffiliate202309ShopProductsGetRequest) PageSize(pageSize int32) ApiAffiliate202309ShopProductsGetRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliate202309ShopProductsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliate202309ShopProductsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliate202309ShopProductsGetRequest) ContentType(contentType string) ApiAffiliate202309ShopProductsGetRequest {
    r.contentType = &contentType
    return r
}
// The pagination offset that determines where you begin your search. If you are making your first request, this will be empty.
func (r ApiAffiliate202309ShopProductsGetRequest) PageToken(pageToken string) ApiAffiliate202309ShopProductsGetRequest {
    r.pageToken = &pageToken
    return r
}
// The title keyword of the product you wish to search by.
func (r ApiAffiliate202309ShopProductsGetRequest) TitleKeyword(titleKeyword string) ApiAffiliate202309ShopProductsGetRequest {
    r.titleKeyword = &titleKeyword
    return r
}
// Sort fields include PRODUCT_ID, PRICE and SALE. If sort_field is empty or invalid, PRODUCT_ID will be set as default.
func (r ApiAffiliate202309ShopProductsGetRequest) SortField(sortField string) ApiAffiliate202309ShopProductsGetRequest {
    r.sortField = &sortField
    return r
}
// Sort orders include 0:DESC and 1:ASC. If sort order is empty or invalid, DESC will be set as default.
func (r ApiAffiliate202309ShopProductsGetRequest) SortOrder(sortOrder string) ApiAffiliate202309ShopProductsGetRequest {
    r.sortOrder = &sortOrder
    return r
}
func (r ApiAffiliate202309ShopProductsGetRequest) Execute() (*affiliate_v202309.Affiliate202309GetShopProductsResponse, *http.Response, error) {
    return r.ApiService.Affiliate202309ShopProductsGetExecute(r)
}

/*
Affiliate202309ShopProductsGet GetShopProducts
Developer can utilize this API to search and retrieve products information of shop which is bound by a specific creator with specific keywords.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliate202309ShopProductsGetRequest
*/
func (a *AffiliateV202309APIService) Affiliate202309ShopProductsGet(ctx context.Context) ApiAffiliate202309ShopProductsGetRequest {
    return ApiAffiliate202309ShopProductsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Affiliate202309GetShopProductsResponse
func (a *AffiliateV202309APIService) Affiliate202309ShopProductsGetExecute(r ApiAffiliate202309ShopProductsGetRequest) (*affiliate_v202309.Affiliate202309GetShopProductsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_v202309.Affiliate202309GetShopProductsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateV202309APIService.Affiliate202309ShopProductsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate/202309/shop_products"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.titleKeyword != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "title_keyword", r.titleKeyword, "")
    }
    if r.sortField != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    }
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliate202309ShowcasesProductsDeleteRequest struct {
    ctx context.Context
    ApiService *AffiliateV202309APIService
    xTtsAccessToken *string
    contentType *string
    affiliate202309RemoveShowcaseProductsoldRequestBody *affiliate_v202309.Affiliate202309RemoveShowcaseProductsoldRequestBody
}

// 
func (r ApiAffiliate202309ShowcasesProductsDeleteRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliate202309ShowcasesProductsDeleteRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliate202309ShowcasesProductsDeleteRequest) ContentType(contentType string) ApiAffiliate202309ShowcasesProductsDeleteRequest {
    r.contentType = &contentType
    return r
}
func (r ApiAffiliate202309ShowcasesProductsDeleteRequest) Affiliate202309RemoveShowcaseProductsoldRequestBody(affiliate202309RemoveShowcaseProductsoldRequestBody affiliate_v202309.Affiliate202309RemoveShowcaseProductsoldRequestBody) ApiAffiliate202309ShowcasesProductsDeleteRequest {
    r.affiliate202309RemoveShowcaseProductsoldRequestBody = &affiliate202309RemoveShowcaseProductsoldRequestBody
    return r
}
func (r ApiAffiliate202309ShowcasesProductsDeleteRequest) Execute() (*affiliate_v202309.Affiliate202309RemoveShowcaseProductsoldResponse, *http.Response, error) {
    return r.ApiService.Affiliate202309ShowcasesProductsDeleteExecute(r)
}

/*
Affiliate202309ShowcasesProductsDelete RemoveShowcaseProductsold
This API removes the products in the creator's showcase. The platform will return error code and error message if the deletion fails.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliate202309ShowcasesProductsDeleteRequest
*/
func (a *AffiliateV202309APIService) Affiliate202309ShowcasesProductsDelete(ctx context.Context) ApiAffiliate202309ShowcasesProductsDeleteRequest {
    return ApiAffiliate202309ShowcasesProductsDeleteRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Affiliate202309RemoveShowcaseProductsoldResponse
func (a *AffiliateV202309APIService) Affiliate202309ShowcasesProductsDeleteExecute(r ApiAffiliate202309ShowcasesProductsDeleteRequest) (*affiliate_v202309.Affiliate202309RemoveShowcaseProductsoldResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodDelete
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_v202309.Affiliate202309RemoveShowcaseProductsoldResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateV202309APIService.Affiliate202309ShowcasesProductsDelete")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate/202309/showcases/products"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliate202309RemoveShowcaseProductsoldRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliate202309ShowcasesProductsGetRequest struct {
    ctx context.Context
    ApiService *AffiliateV202309APIService
    xTtsAccessToken *string
    contentType *string
    pageSize *int32
    pageToken *string
    origin *string
}

// 
func (r ApiAffiliate202309ShowcasesProductsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliate202309ShowcasesProductsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliate202309ShowcasesProductsGetRequest) ContentType(contentType string) ApiAffiliate202309ShowcasesProductsGetRequest {
    r.contentType = &contentType
    return r
}
// The maximum number of products returned in the response. Default to be 50 if not set.
func (r ApiAffiliate202309ShowcasesProductsGetRequest) PageSize(pageSize int32) ApiAffiliate202309ShowcasesProductsGetRequest {
    r.pageSize = &pageSize
    return r
}
// The page token 
func (r ApiAffiliate202309ShowcasesProductsGetRequest) PageToken(pageToken string) ApiAffiliate202309ShowcasesProductsGetRequest {
    r.pageToken = &pageToken
    return r
}
// Where the request is sent from. LIVE: sent from live room. The response will return the product IDs in the LIVE as well. The \&quot;add_status\&quot; field will be whether the product is in the live bag, or whether the product is in the prelive product preparation list if the creator is not live streaming. SHOWCASE: sent from showcase. The \&quot;add_status\&quot; field will be whether the product is in the showcase.
func (r ApiAffiliate202309ShowcasesProductsGetRequest) Origin(origin string) ApiAffiliate202309ShowcasesProductsGetRequest {
    r.origin = &origin
    return r
}
func (r ApiAffiliate202309ShowcasesProductsGetRequest) Execute() (*affiliate_v202309.Affiliate202309GetShowcaseProductsoldResponse, *http.Response, error) {
    return r.ApiService.Affiliate202309ShowcasesProductsGetExecute(r)
}

/*
Affiliate202309ShowcasesProductsGet GetShowcaseProductsold
This API lists the products in the creator's showcase, paginated by specified page size and iterated through pages by page token for up to 2000 products in the showcase. This API is generally used when a creator would like to view the products in the showcase.  The platform will return the product details in the showcase, as well as the products in the livebag if the creator is live streaming.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliate202309ShowcasesProductsGetRequest
*/
func (a *AffiliateV202309APIService) Affiliate202309ShowcasesProductsGet(ctx context.Context) ApiAffiliate202309ShowcasesProductsGetRequest {
    return ApiAffiliate202309ShowcasesProductsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Affiliate202309GetShowcaseProductsoldResponse
func (a *AffiliateV202309APIService) Affiliate202309ShowcasesProductsGetExecute(r ApiAffiliate202309ShowcasesProductsGetRequest) (*affiliate_v202309.Affiliate202309GetShowcaseProductsoldResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_v202309.Affiliate202309GetShowcaseProductsoldResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateV202309APIService.Affiliate202309ShowcasesProductsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate/202309/showcases/products"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageSize != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    }
    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    if r.origin != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "origin", r.origin, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliate202309ShowcasesProductsPostRequest struct {
    ctx context.Context
    ApiService *AffiliateV202309APIService
    xTtsAccessToken *string
    contentType *string
    affiliate202309AddShowcaseProductsoldRequestBody *affiliate_v202309.Affiliate202309AddShowcaseProductsoldRequestBody
}

// 
func (r ApiAffiliate202309ShowcasesProductsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliate202309ShowcasesProductsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliate202309ShowcasesProductsPostRequest) ContentType(contentType string) ApiAffiliate202309ShowcasesProductsPostRequest {
    r.contentType = &contentType
    return r
}
func (r ApiAffiliate202309ShowcasesProductsPostRequest) Affiliate202309AddShowcaseProductsoldRequestBody(affiliate202309AddShowcaseProductsoldRequestBody affiliate_v202309.Affiliate202309AddShowcaseProductsoldRequestBody) ApiAffiliate202309ShowcasesProductsPostRequest {
    r.affiliate202309AddShowcaseProductsoldRequestBody = &affiliate202309AddShowcaseProductsoldRequestBody
    return r
}
func (r ApiAffiliate202309ShowcasesProductsPostRequest) Execute() (*affiliate_v202309.Affiliate202309AddShowcaseProductsoldResponse, *http.Response, error) {
    return r.ApiService.Affiliate202309ShowcasesProductsPostExecute(r)
}

/*
Affiliate202309ShowcasesProductsPost AddShowcaseProductsold
This API adds the products to the creator's showcase. The platform will return the add status of the products, and error code and error message if the deletion fails.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliate202309ShowcasesProductsPostRequest
*/
func (a *AffiliateV202309APIService) Affiliate202309ShowcasesProductsPost(ctx context.Context) ApiAffiliate202309ShowcasesProductsPostRequest {
    return ApiAffiliate202309ShowcasesProductsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Affiliate202309AddShowcaseProductsoldResponse
func (a *AffiliateV202309APIService) Affiliate202309ShowcasesProductsPostExecute(r ApiAffiliate202309ShowcasesProductsPostRequest) (*affiliate_v202309.Affiliate202309AddShowcaseProductsoldResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_v202309.Affiliate202309AddShowcaseProductsoldResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateV202309APIService.Affiliate202309ShowcasesProductsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate/202309/showcases/products"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliate202309AddShowcaseProductsoldRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliate202309ShowcasesProductsTopPostRequest struct {
    ctx context.Context
    ApiService *AffiliateV202309APIService
    xTtsAccessToken *string
    contentType *string
    affiliate202309TopShowcaseProductsoldRequestBody *affiliate_v202309.Affiliate202309TopShowcaseProductsoldRequestBody
}

// 
func (r ApiAffiliate202309ShowcasesProductsTopPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliate202309ShowcasesProductsTopPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliate202309ShowcasesProductsTopPostRequest) ContentType(contentType string) ApiAffiliate202309ShowcasesProductsTopPostRequest {
    r.contentType = &contentType
    return r
}
func (r ApiAffiliate202309ShowcasesProductsTopPostRequest) Affiliate202309TopShowcaseProductsoldRequestBody(affiliate202309TopShowcaseProductsoldRequestBody affiliate_v202309.Affiliate202309TopShowcaseProductsoldRequestBody) ApiAffiliate202309ShowcasesProductsTopPostRequest {
    r.affiliate202309TopShowcaseProductsoldRequestBody = &affiliate202309TopShowcaseProductsoldRequestBody
    return r
}
func (r ApiAffiliate202309ShowcasesProductsTopPostRequest) Execute() (*affiliate_v202309.Affiliate202309TopShowcaseProductsoldResponse, *http.Response, error) {
    return r.ApiService.Affiliate202309ShowcasesProductsTopPostExecute(r)
}

/*
Affiliate202309ShowcasesProductsTopPost TopShowcaseProductsold
Use this API to move products to the top in a creator's showcase.  The platform will return the error code and error message if the pinning operation fails.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliate202309ShowcasesProductsTopPostRequest
*/
func (a *AffiliateV202309APIService) Affiliate202309ShowcasesProductsTopPost(ctx context.Context) ApiAffiliate202309ShowcasesProductsTopPostRequest {
    return ApiAffiliate202309ShowcasesProductsTopPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return Affiliate202309TopShowcaseProductsoldResponse
func (a *AffiliateV202309APIService) Affiliate202309ShowcasesProductsTopPostExecute(r ApiAffiliate202309ShowcasesProductsTopPostRequest) (*affiliate_v202309.Affiliate202309TopShowcaseProductsoldResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_v202309.Affiliate202309TopShowcaseProductsoldResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateV202309APIService.Affiliate202309ShowcasesProductsTopPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate/202309/showcases/products/top"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliate202309TopShowcaseProductsoldRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
