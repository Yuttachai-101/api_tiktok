/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "reflect"

    "tiktokshop/open/sdk_golang/models/affiliate_seller/v202410"
)


// AffiliateSellerV202410APIService AffiliateSellerV202410API service
type AffiliateSellerV202410APIService service

type ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202410APIService
    productIds *[]string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// The product IDs to which the sample rules apply.
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest) ProductIds(productIds []string) ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest {
    r.productIds = &productIds
    return r
}
// 
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest) ContentType(contentType string) ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest) Execute() (*affiliate_seller_v202410.AffiliateSeller202410GetOpenCollaborationSampleRulesResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202410OpenCollaborationsSampleRulesGetExecute(r)
}

/*
AffiliateSeller202410OpenCollaborationsSampleRulesGet GetOpenCollaborationSampleRules
Use this API to get the status and the details of the sample rules for products under an open collaboration. With this API, you can efficiently review the sample distribution criteria for products within the open collaboration context.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest
*/
func (a *AffiliateSellerV202410APIService) AffiliateSeller202410OpenCollaborationsSampleRulesGet(ctx context.Context) ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest {
    return ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202410GetOpenCollaborationSampleRulesResponse
func (a *AffiliateSellerV202410APIService) AffiliateSeller202410OpenCollaborationsSampleRulesGetExecute(r ApiAffiliateSeller202410OpenCollaborationsSampleRulesGetRequest) (*affiliate_seller_v202410.AffiliateSeller202410GetOpenCollaborationSampleRulesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202410.AffiliateSeller202410GetOpenCollaborationSampleRulesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202410APIService.AffiliateSeller202410OpenCollaborationsSampleRulesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202410/open_collaborations/sample_rules"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.productIds == nil {
        return localVarReturnValue, nil, reportError("productIds is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    {
        t := *r.productIds
        if reflect.TypeOf(t).Kind() == reflect.Slice {
            s := reflect.ValueOf(t)
            for i := 0; i < s.Len(); i++ {
                parameterAddToHeaderOrQuery(localVarQueryParams, "product_ids", s.Index(i).Interface(), "multi")
            }
        } else {
            parameterAddToHeaderOrQuery(localVarQueryParams, "product_ids", t, "multi")
        }
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202410APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    affiliateSeller202410EditOpenCollaborationSampleRuleRequestBody *affiliate_seller_v202410.AffiliateSeller202410EditOpenCollaborationSampleRuleRequestBody
}

// 
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest) ContentType(contentType string) ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest) AffiliateSeller202410EditOpenCollaborationSampleRuleRequestBody(affiliateSeller202410EditOpenCollaborationSampleRuleRequestBody affiliate_seller_v202410.AffiliateSeller202410EditOpenCollaborationSampleRuleRequestBody) ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest {
    r.affiliateSeller202410EditOpenCollaborationSampleRuleRequestBody = &affiliateSeller202410EditOpenCollaborationSampleRuleRequestBody
    return r
}
func (r ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest) Execute() (*affiliate_seller_v202410.AffiliateSeller202410EditOpenCollaborationSampleRuleResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202410OpenCollaborationsSampleRulesPostExecute(r)
}

/*
AffiliateSeller202410OpenCollaborationsSampleRulesPost EditOpenCollaborationSampleRule
Use this API to manage sample rules in open collaborations, like valid time periods, or thresholds for creators to request samples. You can create, update, or deactivate rules.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest
*/
func (a *AffiliateSellerV202410APIService) AffiliateSeller202410OpenCollaborationsSampleRulesPost(ctx context.Context) ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest {
    return ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202410EditOpenCollaborationSampleRuleResponse
func (a *AffiliateSellerV202410APIService) AffiliateSeller202410OpenCollaborationsSampleRulesPostExecute(r ApiAffiliateSeller202410OpenCollaborationsSampleRulesPostRequest) (*affiliate_seller_v202410.AffiliateSeller202410EditOpenCollaborationSampleRuleResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202410.AffiliateSeller202410EditOpenCollaborationSampleRuleResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202410APIService.AffiliateSeller202410OpenCollaborationsSampleRulesPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202410/open_collaborations/sample_rules"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202410EditOpenCollaborationSampleRuleRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAffiliateSeller202410OrdersSearchPostRequest struct {
    ctx context.Context
    ApiService *AffiliateSellerV202410APIService
    pageSize *int64
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    shopCipher *string
    affiliateSeller202410SearchSellerAffiliateOrdersRequestBody *affiliate_seller_v202410.AffiliateSeller202410SearchSellerAffiliateOrdersRequestBody
}

// The number of results to be returned per page. Default: 20 Valid Range: [1-100]
func (r ApiAffiliateSeller202410OrdersSearchPostRequest) PageSize(pageSize int64) ApiAffiliateSeller202410OrdersSearchPostRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiAffiliateSeller202410OrdersSearchPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiAffiliateSeller202410OrdersSearchPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiAffiliateSeller202410OrdersSearchPostRequest) ContentType(contentType string) ApiAffiliateSeller202410OrdersSearchPostRequest {
    r.contentType = &contentType
    return r
}
// An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the &#x60;next_page_token&#x60; from a previous response. It is not needed for the first page.
func (r ApiAffiliateSeller202410OrdersSearchPostRequest) PageToken(pageToken string) ApiAffiliateSeller202410OrdersSearchPostRequest {
    r.pageToken = &pageToken
    return r
}
// 
func (r ApiAffiliateSeller202410OrdersSearchPostRequest) ShopCipher(shopCipher string) ApiAffiliateSeller202410OrdersSearchPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiAffiliateSeller202410OrdersSearchPostRequest) AffiliateSeller202410SearchSellerAffiliateOrdersRequestBody(affiliateSeller202410SearchSellerAffiliateOrdersRequestBody affiliate_seller_v202410.AffiliateSeller202410SearchSellerAffiliateOrdersRequestBody) ApiAffiliateSeller202410OrdersSearchPostRequest {
    r.affiliateSeller202410SearchSellerAffiliateOrdersRequestBody = &affiliateSeller202410SearchSellerAffiliateOrdersRequestBody
    return r
}
func (r ApiAffiliateSeller202410OrdersSearchPostRequest) Execute() (*affiliate_seller_v202410.AffiliateSeller202410SearchSellerAffiliateOrdersResponse, *http.Response, error) {
    return r.ApiService.AffiliateSeller202410OrdersSearchPostExecute(r)
}

/*
AffiliateSeller202410OrdersSearchPost SearchSellerAffiliateOrders
This API allows the partner to retrieve a list of affiliate orders (orders which are affiliate-commission eligible) generated by a seller, returning the order ID and the product ID. Using this, the partner can track their affiliate-conversions on behalf of a seller, using the order ID.


@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiAffiliateSeller202410OrdersSearchPostRequest
*/
func (a *AffiliateSellerV202410APIService) AffiliateSeller202410OrdersSearchPost(ctx context.Context) ApiAffiliateSeller202410OrdersSearchPostRequest {
    return ApiAffiliateSeller202410OrdersSearchPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return AffiliateSeller202410SearchSellerAffiliateOrdersResponse
func (a *AffiliateSellerV202410APIService) AffiliateSeller202410OrdersSearchPostExecute(r ApiAffiliateSeller202410OrdersSearchPostRequest) (*affiliate_seller_v202410.AffiliateSeller202410SearchSellerAffiliateOrdersResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *affiliate_seller_v202410.AffiliateSeller202410SearchSellerAffiliateOrdersResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AffiliateSellerV202410APIService.AffiliateSeller202410OrdersSearchPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/affiliate_seller/202410/orders/search"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.affiliateSeller202410SearchSellerAffiliateOrdersRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
